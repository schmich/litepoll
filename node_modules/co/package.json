{
  "name": "co",
  "version": "3.0.5",
  "description": "generator async flow control goodness",
  "keywords": [
    "async",
    "flow",
    "generator",
    "coro",
    "coroutine"
  ],
  "devDependencies": {
    "should": "~1.2.2",
    "mocha": "~1.12.0",
    "q": "~0.9.4",
    "thunkify": "0.0.1",
    "request": "~2.27.0",
    "matcha": "~0.4.0"
  },
  "scripts": {
    "test": "make test"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/visionmedia/co.git"
  },
  "readme": "# Co\n\n  [![Build Status](https://travis-ci.org/visionmedia/co.png?branch=master)](https://travis-ci.org/visionmedia/co)\n\n  Generator based flow-control goodness for nodejs (and soon the browser), using\n  thunks _or_ promises, letting you write non-blocking code in a nice-ish\n  way.\n\n  Currently you must use the `--harmony-generators` flag when\n  running node 0.11.x to get access to generators. Or use gnode to spawn your node instance. \n  However note that performance degrades quickly compared to 0.11.x.\n\n  Co is careful to relay any errors that occur back to the generator, including those\n  within the thunk, or from the thunk's callback. \"Uncaught\" exceptions in the generator\n  are passed to `co()`'s thunk.\n\n  Make sure to view the [examples](https://github.com/visionmedia/co/tree/master/examples).\n\n## Installation\n\n```\n$ npm install co\n```\n\n## Associated libraries\n\n  View the [wiki](https://github.com/visionmedia/co/wiki) for libraries that\n  work well with Co.\n\n## Example\n\n```js\nvar co = require('co');\nvar thunkify = require('thunkify');\nvar request = require('request');\nvar get = thunkify(request.get);\n\nco(function *(){\n  var a = yield get('http://google.com');\n  var b = yield get('http://yahoo.com');\n  var c = yield get('http://cloudup.com');\n  console.log(a.status);\n  console.log(b.status);\n  console.log(c.status);\n})()\n\nco(function *(){\n  var a = get('http://google.com');\n  var b = get('http://yahoo.com');\n  var c = get('http://cloudup.com');\n  var res = yield [a, b, c];\n  console.log(res);\n})()\n```\n\n## Yieldables\n\n  The \"yieldable\" objects currently supported are:\n\n  - promises\n  - thunks (functions)\n  - array (parallel execution)\n  - objects (parallel execution)\n  - generators (delegation)\n  - generator functions (delegation)\n\nTo convert a regular node function that accepts a callback into one which returns a thunk you may want to use [thunkify](https://github.com/visionmedia/node-thunkify) or similar.\n\n## Thunks vs promises\n\n  While co supports promises, you may return \"thunks\" from your functions,\n  which otherwise behaves just like the traditional node-style callback\n  with a signature of: `(err, result)`.\n\n\n  For example take `fs.readFile`, we all know the signature is:\n\n```js\nfs.readFile(path, encoding, function(err, result){\n\n});\n```\n\n  To work with Co we need a function to return another function of\n  the same signature:\n\n```js\nfs.readFile(path, encoding)(function(err, result){\n\n});\n```\n\n  Which basically looks like this:\n\n```js\nfunction read(path, encoding) {\n  return function(cb){\n    fs.readFile(path, encoding, cb);\n  }\n}\n```\n\n## Receiver propagation\n\n  When `co` is invoked with a receiver it will propagate to most yieldables,\n  allowing you to alter `this`.\n\n```js\nvar ctx = {};\n\nfunction foo() {\n  assert(this == ctx);\n}\n\nco(function *(){\n  assert(this == ctx);\n  yield foo;\n}).call(ctx)\n```\n\n  You also pass arguments through the generator:\n\n```js\nco(function *(a){\n  assert(this == ctx);\n  assert('yay' == a);\n  yield foo;\n}).call(ctx, 'yay');\n```\n\n## API\n\n### co(fn)\n\n  Pass a generator `fn` and return a thunk. The thunk's signature is\n  `(err, result)`, where `result` is the value passed to the `return`\n  statement.\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction read(file) {\n  return function(fn){\n    fs.readFile(file, 'utf8', fn);\n  }\n}\n\nco(function *(){\n  var a = yield read('.gitignore');\n  var b = yield read('Makefile');\n  var c = yield read('package.json');\n  return [a, b, c];\n})()\n```\n\n  You may also yield `Generator` objects to support nesting:\n\n\n```js\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nfunction *foo(){\n  var a = yield size('.gitignore');\n  var b = yield size('Makefile');\n  var c = yield size('package.json');\n  return [a, b, c];\n}\n\nfunction *bar(){\n  var a = yield size('examples/parallel.js');\n  var b = yield size('examples/nested.js');\n  var c = yield size('examples/simple.js');\n  return [a, b, c];\n}\n\nco(function *(){\n  var a = yield foo();\n  var b = yield bar();\n  console.log(a);\n  console.log(b);\n})()\n```\n\n  Or if the generator functions do not require arguments, simply `yield` the function:\n\n```js\nvar thunkify = require('thunkify');\nvar request = require('superagent');\n\nvar get = thunkify(request.get);\n\nfunction *results() {\n  var a = yield get('http://google.com')\n  var b = yield get('http://yahoo.com')\n  var c = yield get('http://ign.com')\n  return [a.status, b.status, c.status]\n}\n\nco(function *(){\n  // 3 concurrent requests at a time\n  var a = yield results;\n  var b = yield results;\n  var c = yield results;\n  console.log(a, b, c);\n\n  // 9 concurrent requests\n  console.log(yield [results, results, results]);\n})()\n```\n\n  If a thunk is written to execute immediately you may acheive parallelism\n  by simply `yield`-ing _after_ the call. The following are equivalent since\n  each call kicks off execution immediately:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return [yield a, yield b, yield c];\n})()\n```\n\n  Or:\n\n```js\nco(function *(){\n  var a = size('package.json');\n  var b = size('Readme.md');\n  var c = size('Makefile');\n\n  return yield [a, b, c];\n})()\n```\n\n  You can also pass arguments into the generator. The last argument, `done`, is\n  the callback function. Here's an example:\n\n```js\nvar exec = require('co-exec');\nco(function *(cmd) {\n  var res = yield exec(cmd);\n  return res;\n})('pwd', done);\n```\n\n### yield array\n\n  By yielding an array of thunks you may \"join\" them all into a single thunk which executes them all concurrently,\n  instead of in sequence. Note that the resulting array ordering _is_ retained.\n\n```js\n\nvar co = require('co');\nvar fs = require('fs');\n\nfunction size(file) {\n  return function(fn){\n    fs.stat(file, function(err, stat){\n      if (err) return fn(err);\n      fn(null, stat.size);\n    });\n  }\n}\n\nco(function *(){\n  var a = size('.gitignore');\n  var b = size('index.js');\n  var c = size('Makefile');\n  var res = yield [a, b, c];\n  console.log(res);\n  // => [ 13, 1687, 129 ]\n})()\n```\n\nNested arrays may also be expressed as simple nested arrays:\n\n```js\nvar a = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nvar b = [\n  get('http://google.com'),\n  get('http://yahoo.com'),\n  get('http://ign.com')\n];\n\nconsole.log(yield [a, b]);\n```\n\n### yield object\n\n  Yielding an object behaves much like yielding an array, however recursion is supported:\n\n```js\nco(function *(){\n  var user = yield {\n    name: {\n      first: get('name.first'),\n      last: get('name.last')\n    }\n  };\n})()\n```\n\n  Here is the sequential equivalent without yielding an object:\n\n```js\nco(function *(){\n  var user = {\n    name: {\n      first: yield get('name.first'),\n      last: yield get('name.last')\n    }\n  };\n})()\n```\n\n### Performance\n\n  On my machine 30,000 sequential stat()s takes an avg of 570ms,\n  while the same number of sequential stat()s with `co()` takes\n  610ms, aka the overhead introduced by generators is _extremely_ negligable.\n\n## License\n\n  MIT\n\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/visionmedia/co/issues"
  },
  "homepage": "https://github.com/visionmedia/co",
  "_id": "co@3.0.5",
  "dist": {
    "shasum": "39e973d3c0f2392410a4c699a0be22f81096ee56"
  },
  "_from": "co@",
  "_resolved": "https://registry.npmjs.org/co/-/co-3.0.5.tgz"
}
